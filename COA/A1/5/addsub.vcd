$date
	Mon Oct 16 23:32:08 2017
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module adderSubtractor $end
$var wire 1 ! C $end
$var wire 4 " S [3:0] $end
$var reg 4 # A [3:0] $end
$var reg 4 $ B [3:0] $end
$var reg 1 % cin $end
$scope module myAddSub $end
$var wire 4 & A [3:0] $end
$var wire 1 ! C $end
$var wire 4 ' S [3:0] $end
$var wire 4 ( b [3:0] $end
$var wire 1 ) cin $end
$var reg 4 * B [3:0] $end
$var reg 1 + tempCarry $end
$scope begin Ripple_Adder[0] $end
$scope module bitAdder $end
$var wire 1 ! C $end
$var wire 1 , S $end
$var wire 1 - a $end
$var wire 1 . b $end
$var wire 1 / c $end
$var wire 1 0 firstCarry $end
$var wire 1 1 firstSum $end
$var wire 1 2 secondcarry $end
$scope module firstHalf $end
$var wire 1 - a $end
$var wire 1 . b $end
$var reg 1 3 C $end
$var reg 1 4 S $end
$upscope $end
$scope module secondHalf $end
$var wire 1 1 a $end
$var wire 1 / b $end
$var reg 1 5 C $end
$var reg 1 6 S $end
$upscope $end
$upscope $end
$upscope $end
$scope begin Ripple_Adder[1] $end
$scope module bitAdder $end
$var wire 1 ! C $end
$var wire 1 7 S $end
$var wire 1 8 a $end
$var wire 1 9 b $end
$var wire 1 / c $end
$var wire 1 : firstCarry $end
$var wire 1 ; firstSum $end
$var wire 1 < secondcarry $end
$scope module firstHalf $end
$var wire 1 8 a $end
$var wire 1 9 b $end
$var reg 1 = C $end
$var reg 1 > S $end
$upscope $end
$scope module secondHalf $end
$var wire 1 ; a $end
$var wire 1 / b $end
$var reg 1 ? C $end
$var reg 1 @ S $end
$upscope $end
$upscope $end
$upscope $end
$scope begin Ripple_Adder[2] $end
$scope module bitAdder $end
$var wire 1 ! C $end
$var wire 1 A S $end
$var wire 1 B a $end
$var wire 1 C b $end
$var wire 1 / c $end
$var wire 1 D firstCarry $end
$var wire 1 E firstSum $end
$var wire 1 F secondcarry $end
$scope module firstHalf $end
$var wire 1 B a $end
$var wire 1 C b $end
$var reg 1 G C $end
$var reg 1 H S $end
$upscope $end
$scope module secondHalf $end
$var wire 1 E a $end
$var wire 1 / b $end
$var reg 1 I C $end
$var reg 1 J S $end
$upscope $end
$upscope $end
$upscope $end
$scope begin Ripple_Adder[3] $end
$scope module bitAdder $end
$var wire 1 ! C $end
$var wire 1 K S $end
$var wire 1 L a $end
$var wire 1 M b $end
$var wire 1 / c $end
$var wire 1 N firstCarry $end
$var wire 1 O firstSum $end
$var wire 1 P secondcarry $end
$scope module firstHalf $end
$var wire 1 L a $end
$var wire 1 M b $end
$var reg 1 Q C $end
$var reg 1 R S $end
$upscope $end
$scope module secondHalf $end
$var wire 1 O a $end
$var wire 1 / b $end
$var reg 1 S C $end
$var reg 1 T S $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0T
1S
1R
0Q
1P
1O
0N
1M
0L
0K
0J
1I
1H
0G
1F
1E
0D
0C
1B
0A
0@
1?
1>
0=
1<
1;
0:
09
18
07
06
15
14
03
12
11
00
1/
1.
0-
0,
1+
b1001 *
1)
b110 (
b0 '
b110 &
1%
b110 $
b110 #
b0 "
1!
$end
#100
05
02
16
1,
b1 "
b1 '
13
10
04
01
1-
b111 #
b111 &
#200
x!
15
12
06
0,
0?
0<
1@
17
0I
0F
1J
1A
0S
0P
1T
1K
b1110 "
b1110 '
03
00
14
11
0>
0;
0H
0E
1Q
1N
0R
0O
0-
08
0B
1L
b1000 #
b1000 &
#300
05
02
16
1,
b1111 "
b1111 '
13
10
04
01
1-
b1001 #
b1001 &
#400
15
12
06
0,
1?
1<
0@
07
b1100 "
b1100 '
03
00
14
11
1>
1;
0-
18
b1010 #
b1010 &
#500
05
02
16
1,
b1101 "
b1101 '
13
10
04
01
1-
b1011 #
b1011 &
#600
x!
15
12
06
0,
0?
0<
1@
17
1I
1F
0J
0A
b1010 "
b1010 '
03
00
14
11
0>
0;
1H
1E
0-
08
1B
b1100 #
b1100 &
#700
05
02
16
1,
b1011 "
b1011 '
13
10
04
01
1-
b1101 #
b1101 &
#800
1!
15
12
06
0,
1?
1<
0@
07
b1000 "
b1000 '
03
00
14
11
1>
1;
0-
18
b1110 #
b1110 &
#900
