$date
	Tue Oct 17 12:18:35 2017
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module adderSubtractor $end
$var wire 5 ! C [4:0] $end
$var wire 4 " S [3:0] $end
$var reg 4 # A [3:0] $end
$var reg 4 $ B [3:0] $end
$var reg 1 % cin $end
$scope module myAddSub $end
$var wire 4 & A [3:0] $end
$var wire 5 ' C [4:0] $end
$var wire 4 ( S [3:0] $end
$var wire 4 ) b [3:0] $end
$var wire 1 * cin $end
$var reg 4 + B [3:0] $end
$scope begin Ripple_Adder[0] $end
$scope module bitAdder $end
$var wire 1 , C $end
$var wire 1 - S $end
$var wire 1 . a $end
$var wire 1 / b $end
$var wire 1 0 c $end
$var wire 1 1 firstCarry $end
$var wire 1 2 firstSum $end
$var wire 1 3 secondcarry $end
$scope module firstHalf $end
$var wire 1 . a $end
$var wire 1 / b $end
$var reg 1 4 C $end
$var reg 1 5 S $end
$upscope $end
$scope module secondHalf $end
$var wire 1 2 a $end
$var wire 1 0 b $end
$var reg 1 6 C $end
$var reg 1 7 S $end
$upscope $end
$upscope $end
$upscope $end
$scope begin Ripple_Adder[1] $end
$scope module bitAdder $end
$var wire 1 8 C $end
$var wire 1 9 S $end
$var wire 1 : a $end
$var wire 1 ; b $end
$var wire 1 < c $end
$var wire 1 = firstCarry $end
$var wire 1 > firstSum $end
$var wire 1 ? secondcarry $end
$scope module firstHalf $end
$var wire 1 : a $end
$var wire 1 ; b $end
$var reg 1 @ C $end
$var reg 1 A S $end
$upscope $end
$scope module secondHalf $end
$var wire 1 > a $end
$var wire 1 < b $end
$var reg 1 B C $end
$var reg 1 C S $end
$upscope $end
$upscope $end
$upscope $end
$scope begin Ripple_Adder[2] $end
$scope module bitAdder $end
$var wire 1 D C $end
$var wire 1 E S $end
$var wire 1 F a $end
$var wire 1 G b $end
$var wire 1 H c $end
$var wire 1 I firstCarry $end
$var wire 1 J firstSum $end
$var wire 1 K secondcarry $end
$scope module firstHalf $end
$var wire 1 F a $end
$var wire 1 G b $end
$var reg 1 L C $end
$var reg 1 M S $end
$upscope $end
$scope module secondHalf $end
$var wire 1 J a $end
$var wire 1 H b $end
$var reg 1 N C $end
$var reg 1 O S $end
$upscope $end
$upscope $end
$upscope $end
$scope begin Ripple_Adder[3] $end
$scope module bitAdder $end
$var wire 1 P C $end
$var wire 1 Q S $end
$var wire 1 R a $end
$var wire 1 S b $end
$var wire 1 T c $end
$var wire 1 U firstCarry $end
$var wire 1 V firstSum $end
$var wire 1 W secondcarry $end
$scope module firstHalf $end
$var wire 1 R a $end
$var wire 1 S b $end
$var reg 1 X C $end
$var reg 1 Y S $end
$upscope $end
$scope module secondHalf $end
$var wire 1 V a $end
$var wire 1 T b $end
$var reg 1 Z C $end
$var reg 1 [ S $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
1[
0Z
1Y
0X
0W
1V
0U
0T
1S
0R
1Q
0P
1O
0N
0M
0L
0K
0J
0I
1H
0G
0F
1E
0D
0C
1B
1A
0@
1?
1>
0=
1<
0;
1:
09
18
07
16
15
04
13
12
01
10
1/
0.
0-
1,
b1001 +
1*
b110 )
b1100 (
b111 '
b10 &
1%
b110 $
b10 #
b1100 "
b111 !
$end
#100
06
03
17
1-
b1101 "
b1101 (
14
11
05
02
1.
b11 #
b11 &
#200
0P
0Z
0W
1[
1Q
0H
0T
08
0D
b11 !
b11 '
16
13
07
0-
0B
0?
1C
19
0N
0K
1O
1E
b1110 "
b1110 (
04
01
15
12
0A
0>
1M
1J
0.
0:
1F
b100 #
b100 &
#300
06
03
17
1-
b1111 "
b1111 (
14
11
05
02
1.
b101 #
b101 &
#400
1P
1Z
1W
0[
0Q
1T
1D
1N
1K
0O
0E
1H
18
b11111 !
b11111 '
16
13
07
0-
1B
1?
0C
09
b0 "
b0 (
04
01
15
12
1A
1>
0.
1:
b110 #
b110 &
#500
06
03
17
1-
b1 "
b1 (
14
11
05
02
1.
b111 #
b111 &
#600
0H
0T
08
0D
b10011 !
b10011 '
16
13
07
0-
0B
0?
1C
19
0N
0K
0O
0E
0Z
0W
0[
0Q
b10 "
b10 (
04
01
15
12
0A
0>
0M
0J
1X
1U
0Y
0V
0.
0:
0F
1R
b1000 #
b1000 &
#700
06
03
17
1-
b11 "
b11 (
14
11
05
02
1.
b1001 #
b1001 &
#800
1O
1E
1H
18
b10111 !
b10111 '
16
13
07
0-
1B
1?
0C
09
b100 "
b100 (
04
01
15
12
1A
1>
0.
1:
b1010 #
b1010 &
#900
